"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/04_vision.VisionBlock.ipynb.

# %% auto 0
__all__ = ['VisionBlock', 'Cifar10_20clients']

# %% ../../nbs/04_vision.VisionBlock.ipynb 3
import numpy as np
import os
import sys
import random
import gc
import h5py
import torch
import torchvision
import torch.nn as nn
import gdown
import zipfile
from sklearn.model_selection import train_test_split
import ujson
import torchvision.transforms as transforms
from fastcore.utils import *
from .downloader import *

# %% ../../nbs/04_vision.VisionBlock.ipynb 4
random.seed(42)
np.random.seed(42)
torch.manual_seed(42)

# %% ../../nbs/04_vision.VisionBlock.ipynb 5
class VisionBlock(torch.utils.data.Dataset):
    def __init__(self, cfg, id, train= True, download= True, transform=None):
        self.cfg = cfg
        self.config_path = os.path.join(self.cfg.data.data_dir, self.cfg.data.name , "config.json")
        self.train_path = os.path.join(self.cfg.data.data_dir, self.cfg.data.name , "train")
        self.test_path = os.path.join(self.cfg.data.data_dir, self.cfg.data.name, "test")
        self.train = train
        self.transform = transform
        self.id = id

        if download:
            self.download_data()
        
    def download_data(self):
        self.downloader = VisionDownloader(self.cfg, self.transform)
        if isinstance(self.downloader.dataset_content, (list, tuple, np.ndarray)):
            train_data, test_data, stats = self.downloader.partition()
            print('saving')
            self.downloader.save_partitions(train_data, test_data, stats)
            del self.downloader
            gc.collect()
            
    def tensorify(self, data):
        X = torch.tensor(data['x'], dtype= torch.float32)
        y = torch.tensor(data['y'], dtype= torch.int64)
        return {'x': X, 'y': y}

    def load_single_client_data(self, idx):
        path, dir = (self.train_path, 'train') if self.train else (self.test_path, 'test')

        with h5py.File(os.path.join(path, f'{dir}_data.h5'), 'r') as hf_file:
            client_data = hf_file[f'client_{self.id}']
            data = {key: client_data[key][idx] for key in client_data.keys()}
            data = self.tensorify(data)
        return data
    
    def __getitem__(self, idx):
        if idx < 0: # manage minus idx
            idx = len(self) + idx
        return self.load_single_client_data(idx)
    
    def __len__(self):
        path, dir = (self.train_path, 'train') if self.train else (self.test_path, 'test')
        with h5py.File(os.path.join(path, f'{dir}_data.h5'), 'r') as hf_file:
            client_data = hf_file[f'client_{self.id}']
            return len(client_data['x'])

# %% ../../nbs/04_vision.VisionBlock.ipynb 6
class Cifar10_20clients(torch.utils.data.Dataset):
    def __init__(self, cfg, id, train= True, download= True):
        self.cfg = cfg
        self.config_path = os.path.join(self.cfg.data.data_dir, self.cfg.data.name , "config.json")
        self.train_path = os.path.join(self.cfg.data.data_dir, self.cfg.data.name , "train")
        self.test_path = os.path.join(self.cfg.data.data_dir, self.cfg.data.name, "test")
        self.train = train
        self.id = id
        self.download_data()
        self.data = self.load_client_data()
    
    
    def download_data(self):
        if os.path.exists(os.path.join(self.cfg.data.data_dir, self.cfg.data.name, "cifar10_train_20.zip")):
            return
        else:
            os.makedirs(os.path.join(self.cfg.data.data_dir, self.cfg.data.name), exist_ok= True)
        
        if self.train:
            url = "https://drive.google.com/file/d/14NBQaoW8etKzJ70Jf7BuANkR8MsN-j2Q/view?usp=sharing"
            output = os.path.join(self.cfg.data.data_dir, self.cfg.data.name, "cifar10_train_20.zip")
        else:
            url = "https://drive.google.com/file/d/1H1_QDLVXfipwauLEA8RJy1vfq4X8V9je/view?usp=sharing"
            output = os.path.join(self.cfg.data.data_dir, self.cfg.data.name, "cifar10_test_20.zip")

        gdown.download(url=url, output=output, fuzzy=True)
        with zipfile.ZipFile(output, 'r') as zip_ref:
            zip_ref.extractall(f'{self.train_path}' if self.train else f'{self.test_path}')

        print(f'Data downloaded and extracted to {self.train_path if self.train else self.test_path}')
            
    def tensorify(self, data):
        X = torch.tensor(data['x'], dtype= torch.float32)
        y = torch.tensor(data['y'], dtype= torch.int64)
        return {'x': X, 'y': y}

    def load_client_data(self):
        path, dir = (self.train_path, 'train') if self.train else (self.test_path, 'test')
        if self.id < 10:
            id = f'0000{self.id}'
        else:
            id = f'000{self.id}'
        
        with h5py.File(os.path.join(path, f'f_{id}'), 'r') as hf_file:
            x = hf_file['x'][:]
            y = hf_file['y'][:]
        return self.tensorify({'x': x, 'y': y})
    
    def __getitem__(self, idx):
        x = self.data['x'][idx]
        y = self.data['y'][idx]
        return {'x': x, 'y': y}
    
    def __len__(self):
        return len(self.data)
