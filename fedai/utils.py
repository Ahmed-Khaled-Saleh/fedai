"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_utils.ipynb.ipynb.

# %% auto 0
__all__ = ['get_class', 'get_server', 'load_config', 'save_space', 'prepare_dl', 'generate_graph', 'draw_nx_graph', 'draw_matrix',
           'LazyList']

# %% ../nbs/05_utils.ipynb.ipynb 3
import os
from fastcore.utils import *  # noqa: F403
from torch.utils.data import DataLoader
import yaml
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import torch
from .data import * # noqa: F403
from .vision.models import * # noqa: F403


# %% ../nbs/05_utils.ipynb.ipynb 4
import importlib
def get_class(module_name, class_name):
    module = importlib.import_module(module_name)
    return getattr(module, class_name)

# %% ../nbs/05_utils.ipynb.ipynb 5
def get_server(cfg, lst_data_dict, model, holdout_ds, **kwargs):
    Server = get_class('fedai.servers', f'Server_{cfg.name}')
    client_class = get_class('fedai.clients', f'Client_{cfg.name}')
    return Server(cfg, lst_data_dict, model, holdout_ds, client_class, **kwargs)

# %% ../nbs/05_utils.ipynb.ipynb 6
def load_config(file_path):
    with open(file_path, 'r') as file:
        return yaml.safe_load(file)

# %% ../nbs/05_utils.ipynb.ipynb 7
def save_space(client) -> None:
    client.clear_model()
    del client.optimizer
    del client
    import gc
    gc.collect()
    if torch.cuda.is_available():
        torch.cuda.empty_cache()

# %% ../nbs/05_utils.ipynb.ipynb 9
def prepare_dl(cfg, ds, shuffle=True, collate_fn=None):
    return DataLoader(
        ds,
        batch_size= cfg.data.batch_size,
        shuffle= shuffle,
        collate_fn= collate_fn     
    )

# %% ../nbs/05_utils.ipynb.ipynb 11
def generate_graph(K, # (np.ndarray): The input matrix.
                   symmetrize=True, # (bool): If True, makes the matrix symmetric.
                   normalize=True, # (bool): If True, normalizes the matrix symmetrically.
                   threshold= 0, # (float or None): If provided, sets values below this threshold to 0.
                   diag_fill= 0): # (float or None): If provided, fills the diagonal with this value.
    
    graph = np.random.randn(K, K)

    # Symmetrize the matrix
    if symmetrize:
        graph = (graph + graph.T) / 2

    # Apply threshold
    if threshold is not None:
        graph = np.where(graph > threshold, graph, 0)

    # Normalize the matrix symmetrically
    if normalize:
        row_sums = graph.sum(axis=1, keepdims=True)
        col_sums = graph.sum(axis=0, keepdims=True)
        norm_factor = np.sqrt(row_sums @ col_sums)  # Symmetric normalization factor
        graph = np.divide(graph, norm_factor, where=norm_factor != 0)

    # Fill the diagonal
    if diag_fill is not None:
        np.fill_diagonal(graph, diag_fill)

    return graph


# %% ../nbs/05_utils.ipynb.ipynb 12
def draw_nx_graph(graph):

    # Create a NetworkX graph
    G = nx.Graph()

    # Add weighted edges
    for i in range(graph.shape[0]):
        for j in range(graph.shape[1]):
            if graph[i, j] > 0:  # Add edge only if weight > 0
                G.add_edge(i, j, weight=graph[i, j])

    # Get edge weights for coloring
    edges = G.edges(data=True)
    weights = [d['weight'] for _, _, d in edges]

    # Normalize weights for coloring (between 0 and 1)
    normalized_weights = (weights - np.min(weights)) / (np.max(weights) - np.min(weights) + 1e-8)

    # Draw the graph
    pos = nx.spring_layout(G)  # Spring layout for positioning
    plt.figure(figsize=(8, 8))

    # Draw nodes
    nx.draw_networkx_nodes(G, pos, node_size=500, node_color="indigo")

    # Draw edges with color mapping
    edges = nx.draw_networkx_edges(
        G, pos, edge_color=normalized_weights, edge_cmap=plt.cm.viridis, width=2
    )

    # Draw labels
    nx.draw_networkx_labels(G, pos, font_size=12, font_color="black")

    # Add a colorbar
    sm = plt.cm.ScalarMappable(cmap=plt.cm.viridis, norm=plt.Normalize(vmin=np.min(weights), vmax=np.max(weights)))
    sm.set_array([])  # This line fixes the issue
    plt.colorbar(sm, label="Edge Weight", ax=plt.gca())

    plt.title("Graph Connections", fontsize=12)
    plt.axis("off")
    plt.show()

# %% ../nbs/05_utils.ipynb.ipynb 13
def draw_matrix(graph):
    # draw adjacency matrix represntation of a graph
    K = graph.shape[0]

    plt.figure(figsize=(8, 8))
    plt.imshow(graph, cmap='viridis', interpolation='nearest')

    # Add ticks for all nodes
    plt.xticks(ticks=np.arange(K), labels=np.arange(K))
    plt.yticks(ticks=np.arange(K), labels=np.arange(K))

    # Add labels, colorbar, and title
    plt.colorbar(label="Connection Weight")
    plt.title("", fontsize=16)
    plt.xlabel("Node Index")
    plt.ylabel("Node Index")

    # Annotate the weights in the matrix
    for i in range(graph.shape[0]):
        for j in range(graph.shape[1]):
            if graph[i, j] > 0:  # Show only non-zero weights
                plt.text(j, i, f"{graph[i, j]:.3f}", ha='center', va='center', color='white')

    plt.show()


# %% ../nbs/05_utils.ipynb.ipynb 19
class LazyList:
    def __init__(self, server, client_cls):
        self.server = server
        self.client_cls = client_cls
        self.client_cache = {}  # Cache to store initialized clients

    def clear_cache(self):
        # Clear the cache to free memory if needed
        self.client_cache = {}


# %% ../nbs/05_utils.ipynb.ipynb 20
@patch
def __getitem__(self: LazyList, idx):
    # Check if the client is already instantiated
    if idx not in self.client_cache:
        # Instantiate the client and store it in the cache
        self.client_cache[idx] = self.client_cls(
            data_dict= self.server.lst_data_dict[idx],
            model= None, #deepcopy(self.server.model),
            criterion= self.server.criterion,
            optimizer= None, #get_class('torch.optim', self.server.cfg.optimizer)(self.server.model.parameters(), lr= self.server.cfg.lr),
            idx= idx,
            gen_data_dict= self.server.lst_gen_data_dict[idx],
            tokenizer= self.server.tokenizer,
            collat_fn= self.server.collat_fn,
            cfg= self.server.cfg
        )
    return self.client_cache[idx]
